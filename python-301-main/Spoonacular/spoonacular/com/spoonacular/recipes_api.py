# coding: utf-8

"""
    spoonacular API

    The spoonacular Nutrition, Recipe, and Food API allows you to access over 380,000 recipes, thousands of ingredients, 800,000 food products, and 100,000 menu items. Our food ontology and semantic recipe search engine makes it possible to search for recipes using natural language queries, such as \"gluten free brownies without sugar\" or \"low fat vegan cupcakes.\" You can automatically calculate the nutritional information for any recipe, analyze recipe costs, visualize ingredient lists, find recipes for what's in your fridge, find recipes based on special diets, nutritional requirements, or favorite ingredients, classify recipes into types and cuisines, convert ingredient amounts, or even compute an entire meal plan. With our powerful API, you can create many kinds of food and especially nutrition apps.  Special diets/dietary requirements currently available include: vegan, vegetarian, pescetarian, gluten free, grain free, dairy free, high protein, whole 30, low sodium, low carb, Paleo, ketogenic, FODMAP, and Primal.  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: mail@spoonacular.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from spoonacular.api_client import ApiClient
from spoonacular.exceptions import (
    ApiTypeError,
    ApiValueError
)


class RecipesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def analyze_a_recipe_search_query(self, q, **kwargs):  # noqa: E501
        """Analyze a Recipe Search Query  # noqa: E501

        Parse a recipe search query to find out its intention.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analyze_a_recipe_search_query(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: The recipe search query. (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analyze_a_recipe_search_query_with_http_info(q, **kwargs)  # noqa: E501
        else:
            (data) = self.analyze_a_recipe_search_query_with_http_info(q, **kwargs)  # noqa: E501
            return data

    def analyze_a_recipe_search_query_with_http_info(self, q, **kwargs):  # noqa: E501
        """Analyze a Recipe Search Query  # noqa: E501

        Parse a recipe search query to find out its intention.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analyze_a_recipe_search_query_with_http_info(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: The recipe search query. (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analyze_a_recipe_search_query" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'q' is set
        if ('q' not in local_var_params or
                local_var_params['q'] is None):
            raise ApiValueError("Missing the required parameter `q` when calling `analyze_a_recipe_search_query`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in local_var_params:
            query_params.append(('q', local_var_params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/queries/analyze', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analyze_recipe_instructions(self, **kwargs):  # noqa: E501
        """Analyze Recipe Instructions  # noqa: E501

        This endpoint allows you to break down instructions into atomic steps. Furthermore, each step will contain the ingredients and equipment required. Additionally, all ingredients and equipment from the recipe's instructions will be extracted independently of the step they're used in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analyze_recipe_instructions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analyze_recipe_instructions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.analyze_recipe_instructions_with_http_info(**kwargs)  # noqa: E501
            return data

    def analyze_recipe_instructions_with_http_info(self, **kwargs):  # noqa: E501
        """Analyze Recipe Instructions  # noqa: E501

        This endpoint allows you to break down instructions into atomic steps. Furthermore, each step will contain the ingredients and equipment required. Additionally, all ingredients and equipment from the recipe's instructions will be extracted independently of the step they're used in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analyze_recipe_instructions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analyze_recipe_instructions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/analyzeInstructions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def autocomplete_recipe_search(self, **kwargs):  # noqa: E501
        """Autocomplete Recipe Search  # noqa: E501

        Autocomplete a partial input to suggest possible recipe names.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.autocomplete_recipe_search(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: The (natural language) search query.
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :return: list[InlineResponse2007]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.autocomplete_recipe_search_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.autocomplete_recipe_search_with_http_info(**kwargs)  # noqa: E501
            return data

    def autocomplete_recipe_search_with_http_info(self, **kwargs):  # noqa: E501
        """Autocomplete Recipe Search  # noqa: E501

        Autocomplete a partial input to suggest possible recipe names.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.autocomplete_recipe_search_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: The (natural language) search query.
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :return: list[InlineResponse2007]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['query', 'number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method autocomplete_recipe_search" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if 'number' in local_var_params and local_var_params['number'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `autocomplete_recipe_search`, must be a value less than or equal to `100`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `autocomplete_recipe_search`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in local_var_params:
            query_params.append(('query', local_var_params['query']))  # noqa: E501
        if 'number' in local_var_params:
            query_params.append(('number', local_var_params['number']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/autocomplete', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2007]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def classify_cuisine(self, **kwargs):  # noqa: E501
        """Classify Cuisine  # noqa: E501

        Classify the recipe's cuisine.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classify_cuisine(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.classify_cuisine_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.classify_cuisine_with_http_info(**kwargs)  # noqa: E501
            return data

    def classify_cuisine_with_http_info(self, **kwargs):  # noqa: E501
        """Classify Cuisine  # noqa: E501

        Classify the recipe's cuisine.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.classify_cuisine_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method classify_cuisine" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/cuisine', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def compute_glycemic_load(self, inline_object, **kwargs):  # noqa: E501
        """Compute Glycemic Load  # noqa: E501

        Retrieve the glycemic index for a list of ingredients and compute the individual and total glycemic load.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compute_glycemic_load(inline_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InlineObject inline_object: (required)
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.compute_glycemic_load_with_http_info(inline_object, **kwargs)  # noqa: E501
        else:
            (data) = self.compute_glycemic_load_with_http_info(inline_object, **kwargs)  # noqa: E501
            return data

    def compute_glycemic_load_with_http_info(self, inline_object, **kwargs):  # noqa: E501
        """Compute Glycemic Load  # noqa: E501

        Retrieve the glycemic index for a list of ingredients and compute the individual and total glycemic load.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compute_glycemic_load_with_http_info(inline_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InlineObject inline_object: (required)
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['inline_object', 'language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method compute_glycemic_load" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'inline_object' is set
        if ('inline_object' not in local_var_params or
                local_var_params['inline_object'] is None):
            raise ApiValueError("Missing the required parameter `inline_object` when calling `compute_glycemic_load`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'language' in local_var_params:
            query_params.append(('language', local_var_params['language']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'inline_object' in local_var_params:
            body_params = local_var_params['inline_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/food/ingredients/glycemicLoad', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def convert_amounts(self, ingredient_name, source_amount, source_unit, target_unit, **kwargs):  # noqa: E501
        """Convert Amounts  # noqa: E501

        Convert amounts like \"2 cups of flour to grams\".  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.convert_amounts(ingredient_name, source_amount, source_unit, target_unit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ingredient_name: The ingredient which you want to convert. (required)
        :param float source_amount: The amount from which you want to convert, e.g. the 2.5 in \"2.5 cups of flour to grams\". (required)
        :param str source_unit: The unit from which you want to convert, e.g. the grams in \"2.5 cups of flour to grams\". You can also use \"piece\", e.g. \"3.4 oz tomatoes to piece\" (required)
        :param str target_unit: The unit to which you want to convert, e.g. the grams in \"2.5 cups of flour to grams\". You can also use \"piece\", e.g. \"3.4 oz tomatoes to piece\" (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.convert_amounts_with_http_info(ingredient_name, source_amount, source_unit, target_unit, **kwargs)  # noqa: E501
        else:
            (data) = self.convert_amounts_with_http_info(ingredient_name, source_amount, source_unit, target_unit, **kwargs)  # noqa: E501
            return data

    def convert_amounts_with_http_info(self, ingredient_name, source_amount, source_unit, target_unit, **kwargs):  # noqa: E501
        """Convert Amounts  # noqa: E501

        Convert amounts like \"2 cups of flour to grams\".  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.convert_amounts_with_http_info(ingredient_name, source_amount, source_unit, target_unit, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ingredient_name: The ingredient which you want to convert. (required)
        :param float source_amount: The amount from which you want to convert, e.g. the 2.5 in \"2.5 cups of flour to grams\". (required)
        :param str source_unit: The unit from which you want to convert, e.g. the grams in \"2.5 cups of flour to grams\". You can also use \"piece\", e.g. \"3.4 oz tomatoes to piece\" (required)
        :param str target_unit: The unit to which you want to convert, e.g. the grams in \"2.5 cups of flour to grams\". You can also use \"piece\", e.g. \"3.4 oz tomatoes to piece\" (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['ingredient_name', 'source_amount', 'source_unit', 'target_unit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method convert_amounts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ingredient_name' is set
        if ('ingredient_name' not in local_var_params or
                local_var_params['ingredient_name'] is None):
            raise ApiValueError("Missing the required parameter `ingredient_name` when calling `convert_amounts`")  # noqa: E501
        # verify the required parameter 'source_amount' is set
        if ('source_amount' not in local_var_params or
                local_var_params['source_amount'] is None):
            raise ApiValueError("Missing the required parameter `source_amount` when calling `convert_amounts`")  # noqa: E501
        # verify the required parameter 'source_unit' is set
        if ('source_unit' not in local_var_params or
                local_var_params['source_unit'] is None):
            raise ApiValueError("Missing the required parameter `source_unit` when calling `convert_amounts`")  # noqa: E501
        # verify the required parameter 'target_unit' is set
        if ('target_unit' not in local_var_params or
                local_var_params['target_unit'] is None):
            raise ApiValueError("Missing the required parameter `target_unit` when calling `convert_amounts`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ingredient_name' in local_var_params:
            query_params.append(('ingredientName', local_var_params['ingredient_name']))  # noqa: E501
        if 'source_amount' in local_var_params:
            query_params.append(('sourceAmount', local_var_params['source_amount']))  # noqa: E501
        if 'source_unit' in local_var_params:
            query_params.append(('sourceUnit', local_var_params['source_unit']))  # noqa: E501
        if 'target_unit' in local_var_params:
            query_params.append(('targetUnit', local_var_params['target_unit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/convert', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_recipe_card(self, **kwargs):  # noqa: E501
        """Create Recipe Card  # noqa: E501

        Generate a recipe card for a recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_recipe_card(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_recipe_card_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_recipe_card_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_recipe_card_with_http_info(self, **kwargs):  # noqa: E501
        """Create Recipe Card  # noqa: E501

        Generate a recipe card for a recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_recipe_card_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_recipe_card" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/visualizeRecipe', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def equipment_by_id_image(self, id, **kwargs):  # noqa: E501
        """Equipment by ID Image  # noqa: E501

        Visualize a recipe's equipment list as an image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.equipment_by_id_image(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.equipment_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.equipment_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def equipment_by_id_image_with_http_info(self, id, **kwargs):  # noqa: E501
        """Equipment by ID Image  # noqa: E501

        Visualize a recipe's equipment list as an image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.equipment_by_id_image_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method equipment_by_id_image" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `equipment_by_id_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/equipmentWidget.png', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def extract_recipe_from_website(self, url, **kwargs):  # noqa: E501
        """Extract Recipe from Website  # noqa: E501

        This endpoint lets you extract recipe data such as title, ingredients, and instructions from any properly formatted Website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.extract_recipe_from_website(url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str url: The URL of the recipe page. (required)
        :param bool force_extraction: If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower.
        :param bool analyze: If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more.
        :param bool include_nutrition: Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
        :param bool include_taste: Whether taste data should be added to correctly parsed ingredients.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.extract_recipe_from_website_with_http_info(url, **kwargs)  # noqa: E501
        else:
            (data) = self.extract_recipe_from_website_with_http_info(url, **kwargs)  # noqa: E501
            return data

    def extract_recipe_from_website_with_http_info(self, url, **kwargs):  # noqa: E501
        """Extract Recipe from Website  # noqa: E501

        This endpoint lets you extract recipe data such as title, ingredients, and instructions from any properly formatted Website.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.extract_recipe_from_website_with_http_info(url, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str url: The URL of the recipe page. (required)
        :param bool force_extraction: If true, the extraction will be triggered whether we already know the recipe or not. Use this only if information is missing as this operation is slower.
        :param bool analyze: If true, the recipe will be analyzed and classified resolving in more data such as cuisines, dish types, and more.
        :param bool include_nutrition: Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
        :param bool include_taste: Whether taste data should be added to correctly parsed ingredients.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['url', 'force_extraction', 'analyze', 'include_nutrition', 'include_taste']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method extract_recipe_from_website" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'url' is set
        if ('url' not in local_var_params or
                local_var_params['url'] is None):
            raise ApiValueError("Missing the required parameter `url` when calling `extract_recipe_from_website`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'url' in local_var_params:
            query_params.append(('url', local_var_params['url']))  # noqa: E501
        if 'force_extraction' in local_var_params:
            query_params.append(('forceExtraction', local_var_params['force_extraction']))  # noqa: E501
        if 'analyze' in local_var_params:
            query_params.append(('analyze', local_var_params['analyze']))  # noqa: E501
        if 'include_nutrition' in local_var_params:
            query_params.append(('includeNutrition', local_var_params['include_nutrition']))  # noqa: E501
        if 'include_taste' in local_var_params:
            query_params.append(('includeTaste', local_var_params['include_taste']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/extract', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_analyzed_recipe_instructions(self, id, **kwargs):  # noqa: E501
        """Get Analyzed Recipe Instructions  # noqa: E501

        Get an analyzed breakdown of a recipe's instructions. Each step is enriched with the ingredients and equipment required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_analyzed_recipe_instructions(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool step_breakdown: Whether to break down the recipe steps even more.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_analyzed_recipe_instructions_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_analyzed_recipe_instructions_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_analyzed_recipe_instructions_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Analyzed Recipe Instructions  # noqa: E501

        Get an analyzed breakdown of a recipe's instructions. Each step is enriched with the ingredients and equipment required.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_analyzed_recipe_instructions_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool step_breakdown: Whether to break down the recipe steps even more.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'step_breakdown']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_analyzed_recipe_instructions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_analyzed_recipe_instructions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'step_breakdown' in local_var_params:
            query_params.append(('stepBreakdown', local_var_params['step_breakdown']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/analyzedInstructions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_random_recipes(self, **kwargs):  # noqa: E501
        """Get Random Recipes  # noqa: E501

        Find random (popular) recipes. If you need to filter recipes by diet, nutrition etc. you might want to consider using the complex recipe search endpoint and set the sort request parameter to random.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_random_recipes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :param str tags: The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_random_recipes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_random_recipes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_random_recipes_with_http_info(self, **kwargs):  # noqa: E501
        """Get Random Recipes  # noqa: E501

        Find random (popular) recipes. If you need to filter recipes by diet, nutrition etc. you might want to consider using the complex recipe search endpoint and set the sort request parameter to random.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_random_recipes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :param str tags: The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['limit_license', 'tags', 'number']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_random_recipes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if 'number' in local_var_params and local_var_params['number'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `get_random_recipes`, must be a value less than or equal to `100`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `get_random_recipes`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit_license' in local_var_params:
            query_params.append(('limitLicense', local_var_params['limit_license']))  # noqa: E501
        if 'tags' in local_var_params:
            query_params.append(('tags', local_var_params['tags']))  # noqa: E501
        if 'number' in local_var_params:
            query_params.append(('number', local_var_params['number']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/random', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipe_equipment_by_id(self, id, **kwargs):  # noqa: E501
        """Equipment by ID  # noqa: E501

        Get a recipe's equipment list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_equipment_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipe_equipment_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipe_equipment_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipe_equipment_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Equipment by ID  # noqa: E501

        Get a recipe's equipment list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_equipment_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipe_equipment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_recipe_equipment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/equipmentWidget.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipe_information(self, id, **kwargs):  # noqa: E501
        """Get Recipe Information  # noqa: E501

        Use a recipe id to get full information about a recipe, such as ingredients, nutrition, diet and allergen information, etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_information(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool include_nutrition: Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipe_information_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipe_information_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipe_information_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Recipe Information  # noqa: E501

        Use a recipe id to get full information about a recipe, such as ingredients, nutrition, diet and allergen information, etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_information_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool include_nutrition: Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'include_nutrition']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipe_information" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_recipe_information`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'include_nutrition' in local_var_params:
            query_params.append(('includeNutrition', local_var_params['include_nutrition']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/information', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipe_information_bulk(self, ids, **kwargs):  # noqa: E501
        """Get Recipe Information Bulk  # noqa: E501

        Get information about multiple recipes at once. This is equivalent to calling the Get Recipe Information endpoint multiple times, but faster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_information_bulk(ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ids: A comma-separated list of recipe ids. (required)
        :param bool include_nutrition: Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
        :return: list[InlineResponse2004]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipe_information_bulk_with_http_info(ids, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipe_information_bulk_with_http_info(ids, **kwargs)  # noqa: E501
            return data

    def get_recipe_information_bulk_with_http_info(self, ids, **kwargs):  # noqa: E501
        """Get Recipe Information Bulk  # noqa: E501

        Get information about multiple recipes at once. This is equivalent to calling the Get Recipe Information endpoint multiple times, but faster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_information_bulk_with_http_info(ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ids: A comma-separated list of recipe ids. (required)
        :param bool include_nutrition: Include nutrition data in the recipe information. Nutrition data is per serving. If you want the nutrition data for the entire recipe, just multiply by the number of servings.
        :return: list[InlineResponse2004]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['ids', 'include_nutrition']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipe_information_bulk" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'ids' is set
        if ('ids' not in local_var_params or
                local_var_params['ids'] is None):
            raise ApiValueError("Missing the required parameter `ids` when calling `get_recipe_information_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ids' in local_var_params:
            query_params.append(('ids', local_var_params['ids']))  # noqa: E501
        if 'include_nutrition' in local_var_params:
            query_params.append(('includeNutrition', local_var_params['include_nutrition']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/informationBulk', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2004]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipe_ingredients_by_id(self, id, **kwargs):  # noqa: E501
        """Ingredients by ID  # noqa: E501

        Get a recipe's ingredient list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_ingredients_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipe_ingredients_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipe_ingredients_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipe_ingredients_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Ingredients by ID  # noqa: E501

        Get a recipe's ingredient list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_ingredients_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipe_ingredients_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_recipe_ingredients_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/ingredientWidget.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipe_nutrition_widget_by_id(self, id, **kwargs):  # noqa: E501
        """Nutrition by ID  # noqa: E501

        Get a recipe's nutrition data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_nutrition_widget_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipe_nutrition_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipe_nutrition_widget_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipe_nutrition_widget_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Nutrition by ID  # noqa: E501

        Get a recipe's nutrition data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_nutrition_widget_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipe_nutrition_widget_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_recipe_nutrition_widget_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/nutritionWidget.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipe_price_breakdown_by_id(self, id, **kwargs):  # noqa: E501
        """Price Breakdown by ID  # noqa: E501

        Get a recipe's price breakdown data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_price_breakdown_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipe_price_breakdown_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipe_price_breakdown_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipe_price_breakdown_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Price Breakdown by ID  # noqa: E501

        Get a recipe's price breakdown data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_price_breakdown_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipe_price_breakdown_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_recipe_price_breakdown_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/priceBreakdownWidget.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_recipe_taste_by_id(self, id, **kwargs):  # noqa: E501
        """Taste by ID  # noqa: E501

        Get a recipe's taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_taste_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool normalize: Normalize to the strongest taste.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_recipe_taste_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_recipe_taste_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_recipe_taste_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Taste by ID  # noqa: E501

        Get a recipe's taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_recipe_taste_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool normalize: Normalize to the strongest taste.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'normalize']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_recipe_taste_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_recipe_taste_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'normalize' in local_var_params:
            query_params.append(('normalize', local_var_params['normalize']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/tasteWidget.json', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_similar_recipes(self, id, **kwargs):  # noqa: E501
        """Get Similar Recipes  # noqa: E501

        Find recipes which are similar to the given one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_similar_recipes(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :return: list[InlineResponse2005]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_similar_recipes_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_similar_recipes_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_similar_recipes_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Similar Recipes  # noqa: E501

        Find recipes which are similar to the given one.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_similar_recipes_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :return: list[InlineResponse2005]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'number', 'limit_license']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_similar_recipes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `get_similar_recipes`")  # noqa: E501

        if 'number' in local_var_params and local_var_params['number'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `get_similar_recipes`, must be a value less than or equal to `100`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `get_similar_recipes`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'number' in local_var_params:
            query_params.append(('number', local_var_params['number']))  # noqa: E501
        if 'limit_license' in local_var_params:
            query_params.append(('limitLicense', local_var_params['limit_license']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/similar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2005]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def guess_nutrition_by_dish_name(self, title, **kwargs):  # noqa: E501
        """Guess Nutrition by Dish Name  # noqa: E501

        Estimate the macronutrients of a dish based on its title.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.guess_nutrition_by_dish_name(title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str title: The title of the dish. (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.guess_nutrition_by_dish_name_with_http_info(title, **kwargs)  # noqa: E501
        else:
            (data) = self.guess_nutrition_by_dish_name_with_http_info(title, **kwargs)  # noqa: E501
            return data

    def guess_nutrition_by_dish_name_with_http_info(self, title, **kwargs):  # noqa: E501
        """Guess Nutrition by Dish Name  # noqa: E501

        Estimate the macronutrients of a dish based on its title.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.guess_nutrition_by_dish_name_with_http_info(title, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str title: The title of the dish. (required)
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['title']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method guess_nutrition_by_dish_name" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'title' is set
        if ('title' not in local_var_params or
                local_var_params['title'] is None):
            raise ApiValueError("Missing the required parameter `title` when calling `guess_nutrition_by_dish_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'title' in local_var_params:
            query_params.append(('title', local_var_params['title']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/guessNutrition', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ingredients_by_id_image(self, id, **kwargs):  # noqa: E501
        """Ingredients by ID Image  # noqa: E501

        Visualize a recipe's ingredient list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ingredients_by_id_image(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param str measure: Whether the the measures should be 'us' or 'metric'.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ingredients_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.ingredients_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def ingredients_by_id_image_with_http_info(self, id, **kwargs):  # noqa: E501
        """Ingredients by ID Image  # noqa: E501

        Visualize a recipe's ingredient list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ingredients_by_id_image_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param str measure: Whether the the measures should be 'us' or 'metric'.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'measure']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ingredients_by_id_image" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `ingredients_by_id_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'measure' in local_var_params:
            query_params.append(('measure', local_var_params['measure']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/ingredientWidget.png', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def parse_ingredients(self, **kwargs):  # noqa: E501
        """Parse Ingredients  # noqa: E501

        Extract an ingredient from plain text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.parse_ingredients(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: list[InlineResponse20020]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.parse_ingredients_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.parse_ingredients_with_http_info(**kwargs)  # noqa: E501
            return data

    def parse_ingredients_with_http_info(self, **kwargs):  # noqa: E501
        """Parse Ingredients  # noqa: E501

        Extract an ingredient from plain text.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.parse_ingredients_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: list[InlineResponse20020]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method parse_ingredients" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'language' in local_var_params:
            query_params.append(('language', local_var_params['language']))  # noqa: E501

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/parseIngredients', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20020]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def price_breakdown_by_id_image(self, id, **kwargs):  # noqa: E501
        """Price Breakdown by ID Image  # noqa: E501

        Visualize a recipe's price breakdown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.price_breakdown_by_id_image(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.price_breakdown_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.price_breakdown_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def price_breakdown_by_id_image_with_http_info(self, id, **kwargs):  # noqa: E501
        """Price Breakdown by ID Image  # noqa: E501

        Visualize a recipe's price breakdown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.price_breakdown_by_id_image_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method price_breakdown_by_id_image" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `price_breakdown_by_id_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/priceBreakdownWidget.png', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quick_answer(self, q, **kwargs):  # noqa: E501
        """Quick Answer  # noqa: E501

        Answer a nutrition related natural language question.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quick_answer(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: The nutrition related question. (required)
        :return: InlineResponse20050
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quick_answer_with_http_info(q, **kwargs)  # noqa: E501
        else:
            (data) = self.quick_answer_with_http_info(q, **kwargs)  # noqa: E501
            return data

    def quick_answer_with_http_info(self, q, **kwargs):  # noqa: E501
        """Quick Answer  # noqa: E501

        Answer a nutrition related natural language question.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quick_answer_with_http_info(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: The nutrition related question. (required)
        :return: InlineResponse20050
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quick_answer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'q' is set
        if ('q' not in local_var_params or
                local_var_params['q'] is None):
            raise ApiValueError("Missing the required parameter `q` when calling `quick_answer`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in local_var_params:
            query_params.append(('q', local_var_params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/quickAnswer', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20050',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recipe_nutrition_by_id_image(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition by ID Image  # noqa: E501

        Visualize a recipe's nutritional information as an image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_nutrition_by_id_image(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recipe_nutrition_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.recipe_nutrition_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def recipe_nutrition_by_id_image_with_http_info(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition by ID Image  # noqa: E501

        Visualize a recipe's nutritional information as an image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_nutrition_by_id_image_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recipe_nutrition_by_id_image" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `recipe_nutrition_by_id_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/nutritionWidget.png', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recipe_nutrition_label_image(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition Label Image  # noqa: E501

        Get a recipe's nutrition label as an image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_nutrition_label_image(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param bool show_optional_nutrients: Whether to show optional nutrients.
        :param bool show_zero_values: Whether to show zero values.
        :param bool show_ingredients: Whether to show a list of ingredients.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recipe_nutrition_label_image_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.recipe_nutrition_label_image_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def recipe_nutrition_label_image_with_http_info(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition Label Image  # noqa: E501

        Get a recipe's nutrition label as an image.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_nutrition_label_image_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param bool show_optional_nutrients: Whether to show optional nutrients.
        :param bool show_zero_values: Whether to show zero values.
        :param bool show_ingredients: Whether to show a list of ingredients.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'show_optional_nutrients', 'show_zero_values', 'show_ingredients']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recipe_nutrition_label_image" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `recipe_nutrition_label_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'show_optional_nutrients' in local_var_params:
            query_params.append(('showOptionalNutrients', local_var_params['show_optional_nutrients']))  # noqa: E501
        if 'show_zero_values' in local_var_params:
            query_params.append(('showZeroValues', local_var_params['show_zero_values']))  # noqa: E501
        if 'show_ingredients' in local_var_params:
            query_params.append(('showIngredients', local_var_params['show_ingredients']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/nutritionLabel.png', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recipe_nutrition_label_widget(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition Label Widget  # noqa: E501

        Get a recipe's nutrition label as an HTML widget.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_nutrition_label_widget(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :param bool show_optional_nutrients: Whether to show optional nutrients.
        :param bool show_zero_values: Whether to show zero values.
        :param bool show_ingredients: Whether to show a list of ingredients.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recipe_nutrition_label_widget_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.recipe_nutrition_label_widget_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def recipe_nutrition_label_widget_with_http_info(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition Label Widget  # noqa: E501

        Get a recipe's nutrition label as an HTML widget.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_nutrition_label_widget_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :param bool show_optional_nutrients: Whether to show optional nutrients.
        :param bool show_zero_values: Whether to show zero values.
        :param bool show_ingredients: Whether to show a list of ingredients.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'default_css', 'show_optional_nutrients', 'show_zero_values', 'show_ingredients']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recipe_nutrition_label_widget" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `recipe_nutrition_label_widget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'default_css' in local_var_params:
            query_params.append(('defaultCss', local_var_params['default_css']))  # noqa: E501
        if 'show_optional_nutrients' in local_var_params:
            query_params.append(('showOptionalNutrients', local_var_params['show_optional_nutrients']))  # noqa: E501
        if 'show_zero_values' in local_var_params:
            query_params.append(('showZeroValues', local_var_params['show_zero_values']))  # noqa: E501
        if 'show_ingredients' in local_var_params:
            query_params.append(('showIngredients', local_var_params['show_ingredients']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/nutritionLabel', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def recipe_taste_by_id_image(self, id, **kwargs):  # noqa: E501
        """Recipe Taste by ID Image  # noqa: E501

        Get a recipe's taste as an image. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_taste_by_id_image(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param bool normalize: Normalize to the strongest taste.
        :param str rgb: Red, green, blue values for the chart color.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.recipe_taste_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.recipe_taste_by_id_image_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def recipe_taste_by_id_image_with_http_info(self, id, **kwargs):  # noqa: E501
        """Recipe Taste by ID Image  # noqa: E501

        Get a recipe's taste as an image. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.recipe_taste_by_id_image_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float id: The recipe id. (required)
        :param bool normalize: Normalize to the strongest taste.
        :param str rgb: Red, green, blue values for the chart color.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'normalize', 'rgb']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method recipe_taste_by_id_image" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `recipe_taste_by_id_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'normalize' in local_var_params:
            query_params.append(('normalize', local_var_params['normalize']))  # noqa: E501
        if 'rgb' in local_var_params:
            query_params.append(('rgb', local_var_params['rgb']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/png'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/tasteWidget.png', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_recipes(self, **kwargs):  # noqa: E501
        """Search Recipes  # noqa: E501

        Search through hundreds of thousands of recipes using advanced filtering and ranking. NOTE: This method combines searching by query, by ingredients, and by nutrients into one endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_recipes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: The (natural language) search query.
        :param str cuisine: The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as 'OR'). See a full list of supported cuisines.
        :param str exclude_cuisine: The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as 'AND'). See a full list of supported cuisines.
        :param str diet: The diet for which the recipes must be suitable. See a full list of supported diets.
        :param str intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :param str equipment: The equipment required. Multiple values will be interpreted as 'or'. For example, value could be \"blender, frying pan, bowl\".
        :param str include_ingredients: A comma-separated list of ingredients that should/must be used in the recipes.
        :param str exclude_ingredients: A comma-separated list of ingredients or ingredient types that the recipes must not contain.
        :param str type: The type of recipe. See a full list of supported meal types.
        :param bool instructions_required: Whether the recipes must have instructions.
        :param bool fill_ingredients: Add information about the ingredients and whether they are used or missing in relation to the query.
        :param bool add_recipe_information: If set to true, you get more information about the recipes returned.
        :param bool add_recipe_nutrition: If set to true, you get nutritional information about each recipes returned.
        :param str author: The username of the recipe author.
        :param str tags: The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
        :param float recipe_box_id: The id of the recipe box to which the search should be limited to.
        :param str title_match: Enter text that must be found in the title of the recipes.
        :param float max_ready_time: The maximum time in minutes it should take to prepare and cook the recipe.
        :param bool ignore_pantry: Whether to ignore typical pantry items, such as water, salt, flour, etc.
        :param str sort: The strategy to sort recipes by. See a full list of supported sorting options.
        :param str sort_direction: The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).
        :param float min_carbs: The minimum amount of carbohydrates in grams the recipe must have.
        :param float max_carbs: The maximum amount of carbohydrates in grams the recipe can have.
        :param float min_protein: The minimum amount of protein in grams the recipe must have.
        :param float max_protein: The maximum amount of protein in grams the recipe can have.
        :param float min_calories: The minimum amount of calories the recipe must have.
        :param float max_calories: The maximum amount of calories the recipe can have.
        :param float min_fat: The minimum amount of fat in grams the recipe must have.
        :param float max_fat: The maximum amount of fat in grams the recipe can have.
        :param float min_alcohol: The minimum amount of alcohol in grams the recipe must have.
        :param float max_alcohol: The maximum amount of alcohol in grams the recipe can have.
        :param float min_caffeine: The minimum amount of caffeine in milligrams the recipe must have.
        :param float max_caffeine: The maximum amount of caffeine in milligrams the recipe can have.
        :param float min_copper: The minimum amount of copper in milligrams the recipe must have.
        :param float max_copper: The maximum amount of copper in milligrams the recipe can have.
        :param float min_calcium: The minimum amount of calcium in milligrams the recipe must have.
        :param float max_calcium: The maximum amount of calcium in milligrams the recipe can have.
        :param float min_choline: The minimum amount of choline in milligrams the recipe must have.
        :param float max_choline: The maximum amount of choline in milligrams the recipe can have.
        :param float min_cholesterol: The minimum amount of cholesterol in milligrams the recipe must have.
        :param float max_cholesterol: The maximum amount of cholesterol in milligrams the recipe can have.
        :param float min_fluoride: The minimum amount of fluoride in milligrams the recipe must have.
        :param float max_fluoride: The maximum amount of fluoride in milligrams the recipe can have.
        :param float min_saturated_fat: The minimum amount of saturated fat in grams the recipe must have.
        :param float max_saturated_fat: The maximum amount of saturated fat in grams the recipe can have.
        :param float min_vitamin_a: The minimum amount of Vitamin A in IU the recipe must have.
        :param float max_vitamin_a: The maximum amount of Vitamin A in IU the recipe can have.
        :param float min_vitamin_c: The minimum amount of Vitamin C milligrams the recipe must have.
        :param float max_vitamin_c: The maximum amount of Vitamin C in milligrams the recipe can have.
        :param float min_vitamin_d: The minimum amount of Vitamin D in micrograms the recipe must have.
        :param float max_vitamin_d: The maximum amount of Vitamin D in micrograms the recipe can have.
        :param float min_vitamin_e: The minimum amount of Vitamin E in milligrams the recipe must have.
        :param float max_vitamin_e: The maximum amount of Vitamin E in milligrams the recipe can have.
        :param float min_vitamin_k: The minimum amount of Vitamin K in micrograms the recipe must have.
        :param float max_vitamin_k: The maximum amount of Vitamin K in micrograms the recipe can have.
        :param float min_vitamin_b1: The minimum amount of Vitamin B1 in milligrams the recipe must have.
        :param float max_vitamin_b1: The maximum amount of Vitamin B1 in milligrams the recipe can have.
        :param float min_vitamin_b2: The minimum amount of Vitamin B2 in milligrams the recipe must have.
        :param float max_vitamin_b2: The maximum amount of Vitamin B2 in milligrams the recipe can have.
        :param float min_vitamin_b5: The minimum amount of Vitamin B5 in milligrams the recipe must have.
        :param float max_vitamin_b5: The maximum amount of Vitamin B5 in milligrams the recipe can have.
        :param float min_vitamin_b3: The minimum amount of Vitamin B3 in milligrams the recipe must have.
        :param float max_vitamin_b3: The maximum amount of Vitamin B3 in milligrams the recipe can have.
        :param float min_vitamin_b6: The minimum amount of Vitamin B6 in milligrams the recipe must have.
        :param float max_vitamin_b6: The maximum amount of Vitamin B6 in milligrams the recipe can have.
        :param float min_vitamin_b12: The minimum amount of Vitamin B12 in micrograms the recipe must have.
        :param float max_vitamin_b12: The maximum amount of Vitamin B12 in micrograms the recipe can have.
        :param float min_fiber: The minimum amount of fiber in grams the recipe must have.
        :param float max_fiber: The maximum amount of fiber in grams the recipe can have.
        :param float min_folate: The minimum amount of folate in micrograms the recipe must have.
        :param float max_folate: The maximum amount of folate in micrograms the recipe can have.
        :param float min_folic_acid: The minimum amount of folic acid in micrograms the recipe must have.
        :param float max_folic_acid: The maximum amount of folic acid in micrograms the recipe can have.
        :param float min_iodine: The minimum amount of iodine in micrograms the recipe must have.
        :param float max_iodine: The maximum amount of iodine in micrograms the recipe can have.
        :param float min_iron: The minimum amount of iron in milligrams the recipe must have.
        :param float max_iron: The maximum amount of iron in milligrams the recipe can have.
        :param float min_magnesium: The minimum amount of magnesium in milligrams the recipe must have.
        :param float max_magnesium: The maximum amount of magnesium in milligrams the recipe can have.
        :param float min_manganese: The minimum amount of manganese in milligrams the recipe must have.
        :param float max_manganese: The maximum amount of manganese in milligrams the recipe can have.
        :param float min_phosphorus: The minimum amount of phosphorus in milligrams the recipe must have.
        :param float max_phosphorus: The maximum amount of phosphorus in milligrams the recipe can have.
        :param float min_potassium: The minimum amount of potassium in milligrams the recipe must have.
        :param float max_potassium: The maximum amount of potassium in milligrams the recipe can have.
        :param float min_selenium: The minimum amount of selenium in micrograms the recipe must have.
        :param float max_selenium: The maximum amount of selenium in micrograms the recipe can have.
        :param float min_sodium: The minimum amount of sodium in milligrams the recipe must have.
        :param float max_sodium: The maximum amount of sodium in milligrams the recipe can have.
        :param float min_sugar: The minimum amount of sugar in grams the recipe must have.
        :param float max_sugar: The maximum amount of sugar in grams the recipe can have.
        :param float min_zinc: The minimum amount of zinc in milligrams the recipe must have.
        :param float max_zinc: The maximum amount of zinc in milligrams the recipe can have.
        :param int offset: The number of results to skip (between 0 and 900).
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_recipes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_recipes_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_recipes_with_http_info(self, **kwargs):  # noqa: E501
        """Search Recipes  # noqa: E501

        Search through hundreds of thousands of recipes using advanced filtering and ranking. NOTE: This method combines searching by query, by ingredients, and by nutrients into one endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_recipes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: The (natural language) search query.
        :param str cuisine: The cuisine(s) of the recipes. One or more, comma separated (will be interpreted as 'OR'). See a full list of supported cuisines.
        :param str exclude_cuisine: The cuisine(s) the recipes must not match. One or more, comma separated (will be interpreted as 'AND'). See a full list of supported cuisines.
        :param str diet: The diet for which the recipes must be suitable. See a full list of supported diets.
        :param str intolerances: A comma-separated list of intolerances. All recipes returned must not contain ingredients that are not suitable for people with the intolerances entered. See a full list of supported intolerances.
        :param str equipment: The equipment required. Multiple values will be interpreted as 'or'. For example, value could be \"blender, frying pan, bowl\".
        :param str include_ingredients: A comma-separated list of ingredients that should/must be used in the recipes.
        :param str exclude_ingredients: A comma-separated list of ingredients or ingredient types that the recipes must not contain.
        :param str type: The type of recipe. See a full list of supported meal types.
        :param bool instructions_required: Whether the recipes must have instructions.
        :param bool fill_ingredients: Add information about the ingredients and whether they are used or missing in relation to the query.
        :param bool add_recipe_information: If set to true, you get more information about the recipes returned.
        :param bool add_recipe_nutrition: If set to true, you get nutritional information about each recipes returned.
        :param str author: The username of the recipe author.
        :param str tags: The tags (can be diets, meal types, cuisines, or intolerances) that the recipe must have.
        :param float recipe_box_id: The id of the recipe box to which the search should be limited to.
        :param str title_match: Enter text that must be found in the title of the recipes.
        :param float max_ready_time: The maximum time in minutes it should take to prepare and cook the recipe.
        :param bool ignore_pantry: Whether to ignore typical pantry items, such as water, salt, flour, etc.
        :param str sort: The strategy to sort recipes by. See a full list of supported sorting options.
        :param str sort_direction: The direction in which to sort. Must be either 'asc' (ascending) or 'desc' (descending).
        :param float min_carbs: The minimum amount of carbohydrates in grams the recipe must have.
        :param float max_carbs: The maximum amount of carbohydrates in grams the recipe can have.
        :param float min_protein: The minimum amount of protein in grams the recipe must have.
        :param float max_protein: The maximum amount of protein in grams the recipe can have.
        :param float min_calories: The minimum amount of calories the recipe must have.
        :param float max_calories: The maximum amount of calories the recipe can have.
        :param float min_fat: The minimum amount of fat in grams the recipe must have.
        :param float max_fat: The maximum amount of fat in grams the recipe can have.
        :param float min_alcohol: The minimum amount of alcohol in grams the recipe must have.
        :param float max_alcohol: The maximum amount of alcohol in grams the recipe can have.
        :param float min_caffeine: The minimum amount of caffeine in milligrams the recipe must have.
        :param float max_caffeine: The maximum amount of caffeine in milligrams the recipe can have.
        :param float min_copper: The minimum amount of copper in milligrams the recipe must have.
        :param float max_copper: The maximum amount of copper in milligrams the recipe can have.
        :param float min_calcium: The minimum amount of calcium in milligrams the recipe must have.
        :param float max_calcium: The maximum amount of calcium in milligrams the recipe can have.
        :param float min_choline: The minimum amount of choline in milligrams the recipe must have.
        :param float max_choline: The maximum amount of choline in milligrams the recipe can have.
        :param float min_cholesterol: The minimum amount of cholesterol in milligrams the recipe must have.
        :param float max_cholesterol: The maximum amount of cholesterol in milligrams the recipe can have.
        :param float min_fluoride: The minimum amount of fluoride in milligrams the recipe must have.
        :param float max_fluoride: The maximum amount of fluoride in milligrams the recipe can have.
        :param float min_saturated_fat: The minimum amount of saturated fat in grams the recipe must have.
        :param float max_saturated_fat: The maximum amount of saturated fat in grams the recipe can have.
        :param float min_vitamin_a: The minimum amount of Vitamin A in IU the recipe must have.
        :param float max_vitamin_a: The maximum amount of Vitamin A in IU the recipe can have.
        :param float min_vitamin_c: The minimum amount of Vitamin C milligrams the recipe must have.
        :param float max_vitamin_c: The maximum amount of Vitamin C in milligrams the recipe can have.
        :param float min_vitamin_d: The minimum amount of Vitamin D in micrograms the recipe must have.
        :param float max_vitamin_d: The maximum amount of Vitamin D in micrograms the recipe can have.
        :param float min_vitamin_e: The minimum amount of Vitamin E in milligrams the recipe must have.
        :param float max_vitamin_e: The maximum amount of Vitamin E in milligrams the recipe can have.
        :param float min_vitamin_k: The minimum amount of Vitamin K in micrograms the recipe must have.
        :param float max_vitamin_k: The maximum amount of Vitamin K in micrograms the recipe can have.
        :param float min_vitamin_b1: The minimum amount of Vitamin B1 in milligrams the recipe must have.
        :param float max_vitamin_b1: The maximum amount of Vitamin B1 in milligrams the recipe can have.
        :param float min_vitamin_b2: The minimum amount of Vitamin B2 in milligrams the recipe must have.
        :param float max_vitamin_b2: The maximum amount of Vitamin B2 in milligrams the recipe can have.
        :param float min_vitamin_b5: The minimum amount of Vitamin B5 in milligrams the recipe must have.
        :param float max_vitamin_b5: The maximum amount of Vitamin B5 in milligrams the recipe can have.
        :param float min_vitamin_b3: The minimum amount of Vitamin B3 in milligrams the recipe must have.
        :param float max_vitamin_b3: The maximum amount of Vitamin B3 in milligrams the recipe can have.
        :param float min_vitamin_b6: The minimum amount of Vitamin B6 in milligrams the recipe must have.
        :param float max_vitamin_b6: The maximum amount of Vitamin B6 in milligrams the recipe can have.
        :param float min_vitamin_b12: The minimum amount of Vitamin B12 in micrograms the recipe must have.
        :param float max_vitamin_b12: The maximum amount of Vitamin B12 in micrograms the recipe can have.
        :param float min_fiber: The minimum amount of fiber in grams the recipe must have.
        :param float max_fiber: The maximum amount of fiber in grams the recipe can have.
        :param float min_folate: The minimum amount of folate in micrograms the recipe must have.
        :param float max_folate: The maximum amount of folate in micrograms the recipe can have.
        :param float min_folic_acid: The minimum amount of folic acid in micrograms the recipe must have.
        :param float max_folic_acid: The maximum amount of folic acid in micrograms the recipe can have.
        :param float min_iodine: The minimum amount of iodine in micrograms the recipe must have.
        :param float max_iodine: The maximum amount of iodine in micrograms the recipe can have.
        :param float min_iron: The minimum amount of iron in milligrams the recipe must have.
        :param float max_iron: The maximum amount of iron in milligrams the recipe can have.
        :param float min_magnesium: The minimum amount of magnesium in milligrams the recipe must have.
        :param float max_magnesium: The maximum amount of magnesium in milligrams the recipe can have.
        :param float min_manganese: The minimum amount of manganese in milligrams the recipe must have.
        :param float max_manganese: The maximum amount of manganese in milligrams the recipe can have.
        :param float min_phosphorus: The minimum amount of phosphorus in milligrams the recipe must have.
        :param float max_phosphorus: The maximum amount of phosphorus in milligrams the recipe can have.
        :param float min_potassium: The minimum amount of potassium in milligrams the recipe must have.
        :param float max_potassium: The maximum amount of potassium in milligrams the recipe can have.
        :param float min_selenium: The minimum amount of selenium in micrograms the recipe must have.
        :param float max_selenium: The maximum amount of selenium in micrograms the recipe can have.
        :param float min_sodium: The minimum amount of sodium in milligrams the recipe must have.
        :param float max_sodium: The maximum amount of sodium in milligrams the recipe can have.
        :param float min_sugar: The minimum amount of sugar in grams the recipe must have.
        :param float max_sugar: The maximum amount of sugar in grams the recipe can have.
        :param float min_zinc: The minimum amount of zinc in milligrams the recipe must have.
        :param float max_zinc: The maximum amount of zinc in milligrams the recipe can have.
        :param int offset: The number of results to skip (between 0 and 900).
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['query', 'cuisine', 'exclude_cuisine', 'diet', 'intolerances', 'equipment', 'include_ingredients', 'exclude_ingredients', 'type', 'instructions_required', 'fill_ingredients', 'add_recipe_information', 'add_recipe_nutrition', 'author', 'tags', 'recipe_box_id', 'title_match', 'max_ready_time', 'ignore_pantry', 'sort', 'sort_direction', 'min_carbs', 'max_carbs', 'min_protein', 'max_protein', 'min_calories', 'max_calories', 'min_fat', 'max_fat', 'min_alcohol', 'max_alcohol', 'min_caffeine', 'max_caffeine', 'min_copper', 'max_copper', 'min_calcium', 'max_calcium', 'min_choline', 'max_choline', 'min_cholesterol', 'max_cholesterol', 'min_fluoride', 'max_fluoride', 'min_saturated_fat', 'max_saturated_fat', 'min_vitamin_a', 'max_vitamin_a', 'min_vitamin_c', 'max_vitamin_c', 'min_vitamin_d', 'max_vitamin_d', 'min_vitamin_e', 'max_vitamin_e', 'min_vitamin_k', 'max_vitamin_k', 'min_vitamin_b1', 'max_vitamin_b1', 'min_vitamin_b2', 'max_vitamin_b2', 'min_vitamin_b5', 'max_vitamin_b5', 'min_vitamin_b3', 'max_vitamin_b3', 'min_vitamin_b6', 'max_vitamin_b6', 'min_vitamin_b12', 'max_vitamin_b12', 'min_fiber', 'max_fiber', 'min_folate', 'max_folate', 'min_folic_acid', 'max_folic_acid', 'min_iodine', 'max_iodine', 'min_iron', 'max_iron', 'min_magnesium', 'max_magnesium', 'min_manganese', 'max_manganese', 'min_phosphorus', 'max_phosphorus', 'min_potassium', 'max_potassium', 'min_selenium', 'max_selenium', 'min_sodium', 'max_sodium', 'min_sugar', 'max_sugar', 'min_zinc', 'max_zinc', 'offset', 'number', 'limit_license']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_recipes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if 'offset' in local_var_params and local_var_params['offset'] > 900:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `offset` when calling `search_recipes`, must be a value less than or equal to `900`")  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `offset` when calling `search_recipes`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `search_recipes`, must be a value less than or equal to `100`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `search_recipes`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in local_var_params:
            query_params.append(('query', local_var_params['query']))  # noqa: E501
        if 'cuisine' in local_var_params:
            query_params.append(('cuisine', local_var_params['cuisine']))  # noqa: E501
        if 'exclude_cuisine' in local_var_params:
            query_params.append(('excludeCuisine', local_var_params['exclude_cuisine']))  # noqa: E501
        if 'diet' in local_var_params:
            query_params.append(('diet', local_var_params['diet']))  # noqa: E501
        if 'intolerances' in local_var_params:
            query_params.append(('intolerances', local_var_params['intolerances']))  # noqa: E501
        if 'equipment' in local_var_params:
            query_params.append(('equipment', local_var_params['equipment']))  # noqa: E501
        if 'include_ingredients' in local_var_params:
            query_params.append(('includeIngredients', local_var_params['include_ingredients']))  # noqa: E501
        if 'exclude_ingredients' in local_var_params:
            query_params.append(('excludeIngredients', local_var_params['exclude_ingredients']))  # noqa: E501
        if 'type' in local_var_params:
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'instructions_required' in local_var_params:
            query_params.append(('instructionsRequired', local_var_params['instructions_required']))  # noqa: E501
        if 'fill_ingredients' in local_var_params:
            query_params.append(('fillIngredients', local_var_params['fill_ingredients']))  # noqa: E501
        if 'add_recipe_information' in local_var_params:
            query_params.append(('addRecipeInformation', local_var_params['add_recipe_information']))  # noqa: E501
        if 'add_recipe_nutrition' in local_var_params:
            query_params.append(('addRecipeNutrition', local_var_params['add_recipe_nutrition']))  # noqa: E501
        if 'author' in local_var_params:
            query_params.append(('author', local_var_params['author']))  # noqa: E501
        if 'tags' in local_var_params:
            query_params.append(('tags', local_var_params['tags']))  # noqa: E501
        if 'recipe_box_id' in local_var_params:
            query_params.append(('recipeBoxId', local_var_params['recipe_box_id']))  # noqa: E501
        if 'title_match' in local_var_params:
            query_params.append(('titleMatch', local_var_params['title_match']))  # noqa: E501
        if 'max_ready_time' in local_var_params:
            query_params.append(('maxReadyTime', local_var_params['max_ready_time']))  # noqa: E501
        if 'ignore_pantry' in local_var_params:
            query_params.append(('ignorePantry', local_var_params['ignore_pantry']))  # noqa: E501
        if 'sort' in local_var_params:
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'sort_direction' in local_var_params:
            query_params.append(('sortDirection', local_var_params['sort_direction']))  # noqa: E501
        if 'min_carbs' in local_var_params:
            query_params.append(('minCarbs', local_var_params['min_carbs']))  # noqa: E501
        if 'max_carbs' in local_var_params:
            query_params.append(('maxCarbs', local_var_params['max_carbs']))  # noqa: E501
        if 'min_protein' in local_var_params:
            query_params.append(('minProtein', local_var_params['min_protein']))  # noqa: E501
        if 'max_protein' in local_var_params:
            query_params.append(('maxProtein', local_var_params['max_protein']))  # noqa: E501
        if 'min_calories' in local_var_params:
            query_params.append(('minCalories', local_var_params['min_calories']))  # noqa: E501
        if 'max_calories' in local_var_params:
            query_params.append(('maxCalories', local_var_params['max_calories']))  # noqa: E501
        if 'min_fat' in local_var_params:
            query_params.append(('minFat', local_var_params['min_fat']))  # noqa: E501
        if 'max_fat' in local_var_params:
            query_params.append(('maxFat', local_var_params['max_fat']))  # noqa: E501
        if 'min_alcohol' in local_var_params:
            query_params.append(('minAlcohol', local_var_params['min_alcohol']))  # noqa: E501
        if 'max_alcohol' in local_var_params:
            query_params.append(('maxAlcohol', local_var_params['max_alcohol']))  # noqa: E501
        if 'min_caffeine' in local_var_params:
            query_params.append(('minCaffeine', local_var_params['min_caffeine']))  # noqa: E501
        if 'max_caffeine' in local_var_params:
            query_params.append(('maxCaffeine', local_var_params['max_caffeine']))  # noqa: E501
        if 'min_copper' in local_var_params:
            query_params.append(('minCopper', local_var_params['min_copper']))  # noqa: E501
        if 'max_copper' in local_var_params:
            query_params.append(('maxCopper', local_var_params['max_copper']))  # noqa: E501
        if 'min_calcium' in local_var_params:
            query_params.append(('minCalcium', local_var_params['min_calcium']))  # noqa: E501
        if 'max_calcium' in local_var_params:
            query_params.append(('maxCalcium', local_var_params['max_calcium']))  # noqa: E501
        if 'min_choline' in local_var_params:
            query_params.append(('minCholine', local_var_params['min_choline']))  # noqa: E501
        if 'max_choline' in local_var_params:
            query_params.append(('maxCholine', local_var_params['max_choline']))  # noqa: E501
        if 'min_cholesterol' in local_var_params:
            query_params.append(('minCholesterol', local_var_params['min_cholesterol']))  # noqa: E501
        if 'max_cholesterol' in local_var_params:
            query_params.append(('maxCholesterol', local_var_params['max_cholesterol']))  # noqa: E501
        if 'min_fluoride' in local_var_params:
            query_params.append(('minFluoride', local_var_params['min_fluoride']))  # noqa: E501
        if 'max_fluoride' in local_var_params:
            query_params.append(('maxFluoride', local_var_params['max_fluoride']))  # noqa: E501
        if 'min_saturated_fat' in local_var_params:
            query_params.append(('minSaturatedFat', local_var_params['min_saturated_fat']))  # noqa: E501
        if 'max_saturated_fat' in local_var_params:
            query_params.append(('maxSaturatedFat', local_var_params['max_saturated_fat']))  # noqa: E501
        if 'min_vitamin_a' in local_var_params:
            query_params.append(('minVitaminA', local_var_params['min_vitamin_a']))  # noqa: E501
        if 'max_vitamin_a' in local_var_params:
            query_params.append(('maxVitaminA', local_var_params['max_vitamin_a']))  # noqa: E501
        if 'min_vitamin_c' in local_var_params:
            query_params.append(('minVitaminC', local_var_params['min_vitamin_c']))  # noqa: E501
        if 'max_vitamin_c' in local_var_params:
            query_params.append(('maxVitaminC', local_var_params['max_vitamin_c']))  # noqa: E501
        if 'min_vitamin_d' in local_var_params:
            query_params.append(('minVitaminD', local_var_params['min_vitamin_d']))  # noqa: E501
        if 'max_vitamin_d' in local_var_params:
            query_params.append(('maxVitaminD', local_var_params['max_vitamin_d']))  # noqa: E501
        if 'min_vitamin_e' in local_var_params:
            query_params.append(('minVitaminE', local_var_params['min_vitamin_e']))  # noqa: E501
        if 'max_vitamin_e' in local_var_params:
            query_params.append(('maxVitaminE', local_var_params['max_vitamin_e']))  # noqa: E501
        if 'min_vitamin_k' in local_var_params:
            query_params.append(('minVitaminK', local_var_params['min_vitamin_k']))  # noqa: E501
        if 'max_vitamin_k' in local_var_params:
            query_params.append(('maxVitaminK', local_var_params['max_vitamin_k']))  # noqa: E501
        if 'min_vitamin_b1' in local_var_params:
            query_params.append(('minVitaminB1', local_var_params['min_vitamin_b1']))  # noqa: E501
        if 'max_vitamin_b1' in local_var_params:
            query_params.append(('maxVitaminB1', local_var_params['max_vitamin_b1']))  # noqa: E501
        if 'min_vitamin_b2' in local_var_params:
            query_params.append(('minVitaminB2', local_var_params['min_vitamin_b2']))  # noqa: E501
        if 'max_vitamin_b2' in local_var_params:
            query_params.append(('maxVitaminB2', local_var_params['max_vitamin_b2']))  # noqa: E501
        if 'min_vitamin_b5' in local_var_params:
            query_params.append(('minVitaminB5', local_var_params['min_vitamin_b5']))  # noqa: E501
        if 'max_vitamin_b5' in local_var_params:
            query_params.append(('maxVitaminB5', local_var_params['max_vitamin_b5']))  # noqa: E501
        if 'min_vitamin_b3' in local_var_params:
            query_params.append(('minVitaminB3', local_var_params['min_vitamin_b3']))  # noqa: E501
        if 'max_vitamin_b3' in local_var_params:
            query_params.append(('maxVitaminB3', local_var_params['max_vitamin_b3']))  # noqa: E501
        if 'min_vitamin_b6' in local_var_params:
            query_params.append(('minVitaminB6', local_var_params['min_vitamin_b6']))  # noqa: E501
        if 'max_vitamin_b6' in local_var_params:
            query_params.append(('maxVitaminB6', local_var_params['max_vitamin_b6']))  # noqa: E501
        if 'min_vitamin_b12' in local_var_params:
            query_params.append(('minVitaminB12', local_var_params['min_vitamin_b12']))  # noqa: E501
        if 'max_vitamin_b12' in local_var_params:
            query_params.append(('maxVitaminB12', local_var_params['max_vitamin_b12']))  # noqa: E501
        if 'min_fiber' in local_var_params:
            query_params.append(('minFiber', local_var_params['min_fiber']))  # noqa: E501
        if 'max_fiber' in local_var_params:
            query_params.append(('maxFiber', local_var_params['max_fiber']))  # noqa: E501
        if 'min_folate' in local_var_params:
            query_params.append(('minFolate', local_var_params['min_folate']))  # noqa: E501
        if 'max_folate' in local_var_params:
            query_params.append(('maxFolate', local_var_params['max_folate']))  # noqa: E501
        if 'min_folic_acid' in local_var_params:
            query_params.append(('minFolicAcid', local_var_params['min_folic_acid']))  # noqa: E501
        if 'max_folic_acid' in local_var_params:
            query_params.append(('maxFolicAcid', local_var_params['max_folic_acid']))  # noqa: E501
        if 'min_iodine' in local_var_params:
            query_params.append(('minIodine', local_var_params['min_iodine']))  # noqa: E501
        if 'max_iodine' in local_var_params:
            query_params.append(('maxIodine', local_var_params['max_iodine']))  # noqa: E501
        if 'min_iron' in local_var_params:
            query_params.append(('minIron', local_var_params['min_iron']))  # noqa: E501
        if 'max_iron' in local_var_params:
            query_params.append(('maxIron', local_var_params['max_iron']))  # noqa: E501
        if 'min_magnesium' in local_var_params:
            query_params.append(('minMagnesium', local_var_params['min_magnesium']))  # noqa: E501
        if 'max_magnesium' in local_var_params:
            query_params.append(('maxMagnesium', local_var_params['max_magnesium']))  # noqa: E501
        if 'min_manganese' in local_var_params:
            query_params.append(('minManganese', local_var_params['min_manganese']))  # noqa: E501
        if 'max_manganese' in local_var_params:
            query_params.append(('maxManganese', local_var_params['max_manganese']))  # noqa: E501
        if 'min_phosphorus' in local_var_params:
            query_params.append(('minPhosphorus', local_var_params['min_phosphorus']))  # noqa: E501
        if 'max_phosphorus' in local_var_params:
            query_params.append(('maxPhosphorus', local_var_params['max_phosphorus']))  # noqa: E501
        if 'min_potassium' in local_var_params:
            query_params.append(('minPotassium', local_var_params['min_potassium']))  # noqa: E501
        if 'max_potassium' in local_var_params:
            query_params.append(('maxPotassium', local_var_params['max_potassium']))  # noqa: E501
        if 'min_selenium' in local_var_params:
            query_params.append(('minSelenium', local_var_params['min_selenium']))  # noqa: E501
        if 'max_selenium' in local_var_params:
            query_params.append(('maxSelenium', local_var_params['max_selenium']))  # noqa: E501
        if 'min_sodium' in local_var_params:
            query_params.append(('minSodium', local_var_params['min_sodium']))  # noqa: E501
        if 'max_sodium' in local_var_params:
            query_params.append(('maxSodium', local_var_params['max_sodium']))  # noqa: E501
        if 'min_sugar' in local_var_params:
            query_params.append(('minSugar', local_var_params['min_sugar']))  # noqa: E501
        if 'max_sugar' in local_var_params:
            query_params.append(('maxSugar', local_var_params['max_sugar']))  # noqa: E501
        if 'min_zinc' in local_var_params:
            query_params.append(('minZinc', local_var_params['min_zinc']))  # noqa: E501
        if 'max_zinc' in local_var_params:
            query_params.append(('maxZinc', local_var_params['max_zinc']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'number' in local_var_params:
            query_params.append(('number', local_var_params['number']))  # noqa: E501
        if 'limit_license' in local_var_params:
            query_params.append(('limitLicense', local_var_params['limit_license']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/complexSearch', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_recipes_by_ingredients(self, **kwargs):  # noqa: E501
        """Search Recipes by Ingredients  # noqa: E501

         Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don't currently have (post shopping).           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_recipes_by_ingredients(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ingredients: A comma-separated list of ingredients that the recipes should contain.
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :param float ranking: Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
        :param bool ignore_pantry: Whether to ignore typical pantry items, such as water, salt, flour, etc.
        :return: list[InlineResponse2001]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_recipes_by_ingredients_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_recipes_by_ingredients_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_recipes_by_ingredients_with_http_info(self, **kwargs):  # noqa: E501
        """Search Recipes by Ingredients  # noqa: E501

         Ever wondered what recipes you can cook with the ingredients you have in your fridge or pantry? This endpoint lets you find recipes that either maximize the usage of ingredients you have at hand (pre shopping) or minimize the ingredients that you don't currently have (post shopping).           # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_recipes_by_ingredients_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ingredients: A comma-separated list of ingredients that the recipes should contain.
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :param float ranking: Whether to maximize used ingredients (1) or minimize missing ingredients (2) first.
        :param bool ignore_pantry: Whether to ignore typical pantry items, such as water, salt, flour, etc.
        :return: list[InlineResponse2001]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['ingredients', 'number', 'limit_license', 'ranking', 'ignore_pantry']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_recipes_by_ingredients" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if 'number' in local_var_params and local_var_params['number'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `search_recipes_by_ingredients`, must be a value less than or equal to `100`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `search_recipes_by_ingredients`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ingredients' in local_var_params:
            query_params.append(('ingredients', local_var_params['ingredients']))  # noqa: E501
        if 'number' in local_var_params:
            query_params.append(('number', local_var_params['number']))  # noqa: E501
        if 'limit_license' in local_var_params:
            query_params.append(('limitLicense', local_var_params['limit_license']))  # noqa: E501
        if 'ranking' in local_var_params:
            query_params.append(('ranking', local_var_params['ranking']))  # noqa: E501
        if 'ignore_pantry' in local_var_params:
            query_params.append(('ignorePantry', local_var_params['ignore_pantry']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/findByIngredients', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2001]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_recipes_by_nutrients(self, **kwargs):  # noqa: E501
        """Search Recipes by Nutrients  # noqa: E501

        Find a set of recipes that adhere to the given nutritional limits. You may set limits for macronutrients (calories, protein, fat, and carbohydrate) and/or many micronutrients.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_recipes_by_nutrients(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float min_carbs: The minimum amount of carbohydrates in grams the recipe must have.
        :param float max_carbs: The maximum amount of carbohydrates in grams the recipe can have.
        :param float min_protein: The minimum amount of protein in grams the recipe must have.
        :param float max_protein: The maximum amount of protein in grams the recipe can have.
        :param float min_calories: The minimum amount of calories the recipe must have.
        :param float max_calories: The maximum amount of calories the recipe can have.
        :param float min_fat: The minimum amount of fat in grams the recipe must have.
        :param float max_fat: The maximum amount of fat in grams the recipe can have.
        :param float min_alcohol: The minimum amount of alcohol in grams the recipe must have.
        :param float max_alcohol: The maximum amount of alcohol in grams the recipe can have.
        :param float min_caffeine: The minimum amount of caffeine in milligrams the recipe must have.
        :param float max_caffeine: The maximum amount of caffeine in milligrams the recipe can have.
        :param float min_copper: The minimum amount of copper in milligrams the recipe must have.
        :param float max_copper: The maximum amount of copper in milligrams the recipe can have.
        :param float min_calcium: The minimum amount of calcium in milligrams the recipe must have.
        :param float max_calcium: The maximum amount of calcium in milligrams the recipe can have.
        :param float min_choline: The minimum amount of choline in milligrams the recipe must have.
        :param float max_choline: The maximum amount of choline in milligrams the recipe can have.
        :param float min_cholesterol: The minimum amount of cholesterol in milligrams the recipe must have.
        :param float max_cholesterol: The maximum amount of cholesterol in milligrams the recipe can have.
        :param float min_fluoride: The minimum amount of fluoride in milligrams the recipe must have.
        :param float max_fluoride: The maximum amount of fluoride in milligrams the recipe can have.
        :param float min_saturated_fat: The minimum amount of saturated fat in grams the recipe must have.
        :param float max_saturated_fat: The maximum amount of saturated fat in grams the recipe can have.
        :param float min_vitamin_a: The minimum amount of Vitamin A in IU the recipe must have.
        :param float max_vitamin_a: The maximum amount of Vitamin A in IU the recipe can have.
        :param float min_vitamin_c: The minimum amount of Vitamin C in milligrams the recipe must have.
        :param float max_vitamin_c: The maximum amount of Vitamin C in milligrams the recipe can have.
        :param float min_vitamin_d: The minimum amount of Vitamin D in micrograms the recipe must have.
        :param float max_vitamin_d: The maximum amount of Vitamin D in micrograms the recipe can have.
        :param float min_vitamin_e: The minimum amount of Vitamin E in milligrams the recipe must have.
        :param float max_vitamin_e: The maximum amount of Vitamin E in milligrams the recipe can have.
        :param float min_vitamin_k: The minimum amount of Vitamin K in micrograms the recipe must have.
        :param float max_vitamin_k: The maximum amount of Vitamin K in micrograms the recipe can have.
        :param float min_vitamin_b1: The minimum amount of Vitamin B1 in milligrams the recipe must have.
        :param float max_vitamin_b1: The maximum amount of Vitamin B1 in milligrams the recipe can have.
        :param float min_vitamin_b2: The minimum amount of Vitamin B2 in milligrams the recipe must have.
        :param float max_vitamin_b2: The maximum amount of Vitamin B2 in milligrams the recipe can have.
        :param float min_vitamin_b5: The minimum amount of Vitamin B5 in milligrams the recipe must have.
        :param float max_vitamin_b5: The maximum amount of Vitamin B5 in milligrams the recipe can have.
        :param float min_vitamin_b3: The minimum amount of Vitamin B3 in milligrams the recipe must have.
        :param float max_vitamin_b3: The maximum amount of Vitamin B3 in milligrams the recipe can have.
        :param float min_vitamin_b6: The minimum amount of Vitamin B6 in milligrams the recipe must have.
        :param float max_vitamin_b6: The maximum amount of Vitamin B6 in milligrams the recipe can have.
        :param float min_vitamin_b12: The minimum amount of Vitamin B12 in micrograms the recipe must have.
        :param float max_vitamin_b12: The maximum amount of Vitamin B12 in micrograms the recipe can have.
        :param float min_fiber: The minimum amount of fiber in grams the recipe must have.
        :param float max_fiber: The maximum amount of fiber in grams the recipe can have.
        :param float min_folate: The minimum amount of folate in micrograms the recipe must have.
        :param float max_folate: The maximum amount of folate in micrograms the recipe can have.
        :param float min_folic_acid: The minimum amount of folic acid in micrograms the recipe must have.
        :param float max_folic_acid: The maximum amount of folic acid in micrograms the recipe can have.
        :param float min_iodine: The minimum amount of iodine in micrograms the recipe must have.
        :param float max_iodine: The maximum amount of iodine in micrograms the recipe can have.
        :param float min_iron: The minimum amount of iron in milligrams the recipe must have.
        :param float max_iron: The maximum amount of iron in milligrams the recipe can have.
        :param float min_magnesium: The minimum amount of magnesium in milligrams the recipe must have.
        :param float max_magnesium: The maximum amount of magnesium in milligrams the recipe can have.
        :param float min_manganese: The minimum amount of manganese in milligrams the recipe must have.
        :param float max_manganese: The maximum amount of manganese in milligrams the recipe can have.
        :param float min_phosphorus: The minimum amount of phosphorus in milligrams the recipe must have.
        :param float max_phosphorus: The maximum amount of phosphorus in milligrams the recipe can have.
        :param float min_potassium: The minimum amount of potassium in milligrams the recipe must have.
        :param float max_potassium: The maximum amount of potassium in milligrams the recipe can have.
        :param float min_selenium: The minimum amount of selenium in micrograms the recipe must have.
        :param float max_selenium: The maximum amount of selenium in micrograms the recipe can have.
        :param float min_sodium: The minimum amount of sodium in milligrams the recipe must have.
        :param float max_sodium: The maximum amount of sodium in milligrams the recipe can have.
        :param float min_sugar: The minimum amount of sugar in grams the recipe must have.
        :param float max_sugar: The maximum amount of sugar in grams the recipe can have.
        :param float min_zinc: The minimum amount of zinc in milligrams the recipe must have.
        :param float max_zinc: The maximum amount of zinc in milligrams the recipe can have.
        :param int offset: The number of results to skip (between 0 and 900).
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool random: If true, every request will give you a random set of recipes within the requested limits.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :return: list[InlineResponse2002]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_recipes_by_nutrients_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_recipes_by_nutrients_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_recipes_by_nutrients_with_http_info(self, **kwargs):  # noqa: E501
        """Search Recipes by Nutrients  # noqa: E501

        Find a set of recipes that adhere to the given nutritional limits. You may set limits for macronutrients (calories, protein, fat, and carbohydrate) and/or many micronutrients.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_recipes_by_nutrients_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param float min_carbs: The minimum amount of carbohydrates in grams the recipe must have.
        :param float max_carbs: The maximum amount of carbohydrates in grams the recipe can have.
        :param float min_protein: The minimum amount of protein in grams the recipe must have.
        :param float max_protein: The maximum amount of protein in grams the recipe can have.
        :param float min_calories: The minimum amount of calories the recipe must have.
        :param float max_calories: The maximum amount of calories the recipe can have.
        :param float min_fat: The minimum amount of fat in grams the recipe must have.
        :param float max_fat: The maximum amount of fat in grams the recipe can have.
        :param float min_alcohol: The minimum amount of alcohol in grams the recipe must have.
        :param float max_alcohol: The maximum amount of alcohol in grams the recipe can have.
        :param float min_caffeine: The minimum amount of caffeine in milligrams the recipe must have.
        :param float max_caffeine: The maximum amount of caffeine in milligrams the recipe can have.
        :param float min_copper: The minimum amount of copper in milligrams the recipe must have.
        :param float max_copper: The maximum amount of copper in milligrams the recipe can have.
        :param float min_calcium: The minimum amount of calcium in milligrams the recipe must have.
        :param float max_calcium: The maximum amount of calcium in milligrams the recipe can have.
        :param float min_choline: The minimum amount of choline in milligrams the recipe must have.
        :param float max_choline: The maximum amount of choline in milligrams the recipe can have.
        :param float min_cholesterol: The minimum amount of cholesterol in milligrams the recipe must have.
        :param float max_cholesterol: The maximum amount of cholesterol in milligrams the recipe can have.
        :param float min_fluoride: The minimum amount of fluoride in milligrams the recipe must have.
        :param float max_fluoride: The maximum amount of fluoride in milligrams the recipe can have.
        :param float min_saturated_fat: The minimum amount of saturated fat in grams the recipe must have.
        :param float max_saturated_fat: The maximum amount of saturated fat in grams the recipe can have.
        :param float min_vitamin_a: The minimum amount of Vitamin A in IU the recipe must have.
        :param float max_vitamin_a: The maximum amount of Vitamin A in IU the recipe can have.
        :param float min_vitamin_c: The minimum amount of Vitamin C in milligrams the recipe must have.
        :param float max_vitamin_c: The maximum amount of Vitamin C in milligrams the recipe can have.
        :param float min_vitamin_d: The minimum amount of Vitamin D in micrograms the recipe must have.
        :param float max_vitamin_d: The maximum amount of Vitamin D in micrograms the recipe can have.
        :param float min_vitamin_e: The minimum amount of Vitamin E in milligrams the recipe must have.
        :param float max_vitamin_e: The maximum amount of Vitamin E in milligrams the recipe can have.
        :param float min_vitamin_k: The minimum amount of Vitamin K in micrograms the recipe must have.
        :param float max_vitamin_k: The maximum amount of Vitamin K in micrograms the recipe can have.
        :param float min_vitamin_b1: The minimum amount of Vitamin B1 in milligrams the recipe must have.
        :param float max_vitamin_b1: The maximum amount of Vitamin B1 in milligrams the recipe can have.
        :param float min_vitamin_b2: The minimum amount of Vitamin B2 in milligrams the recipe must have.
        :param float max_vitamin_b2: The maximum amount of Vitamin B2 in milligrams the recipe can have.
        :param float min_vitamin_b5: The minimum amount of Vitamin B5 in milligrams the recipe must have.
        :param float max_vitamin_b5: The maximum amount of Vitamin B5 in milligrams the recipe can have.
        :param float min_vitamin_b3: The minimum amount of Vitamin B3 in milligrams the recipe must have.
        :param float max_vitamin_b3: The maximum amount of Vitamin B3 in milligrams the recipe can have.
        :param float min_vitamin_b6: The minimum amount of Vitamin B6 in milligrams the recipe must have.
        :param float max_vitamin_b6: The maximum amount of Vitamin B6 in milligrams the recipe can have.
        :param float min_vitamin_b12: The minimum amount of Vitamin B12 in micrograms the recipe must have.
        :param float max_vitamin_b12: The maximum amount of Vitamin B12 in micrograms the recipe can have.
        :param float min_fiber: The minimum amount of fiber in grams the recipe must have.
        :param float max_fiber: The maximum amount of fiber in grams the recipe can have.
        :param float min_folate: The minimum amount of folate in micrograms the recipe must have.
        :param float max_folate: The maximum amount of folate in micrograms the recipe can have.
        :param float min_folic_acid: The minimum amount of folic acid in micrograms the recipe must have.
        :param float max_folic_acid: The maximum amount of folic acid in micrograms the recipe can have.
        :param float min_iodine: The minimum amount of iodine in micrograms the recipe must have.
        :param float max_iodine: The maximum amount of iodine in micrograms the recipe can have.
        :param float min_iron: The minimum amount of iron in milligrams the recipe must have.
        :param float max_iron: The maximum amount of iron in milligrams the recipe can have.
        :param float min_magnesium: The minimum amount of magnesium in milligrams the recipe must have.
        :param float max_magnesium: The maximum amount of magnesium in milligrams the recipe can have.
        :param float min_manganese: The minimum amount of manganese in milligrams the recipe must have.
        :param float max_manganese: The maximum amount of manganese in milligrams the recipe can have.
        :param float min_phosphorus: The minimum amount of phosphorus in milligrams the recipe must have.
        :param float max_phosphorus: The maximum amount of phosphorus in milligrams the recipe can have.
        :param float min_potassium: The minimum amount of potassium in milligrams the recipe must have.
        :param float max_potassium: The maximum amount of potassium in milligrams the recipe can have.
        :param float min_selenium: The minimum amount of selenium in micrograms the recipe must have.
        :param float max_selenium: The maximum amount of selenium in micrograms the recipe can have.
        :param float min_sodium: The minimum amount of sodium in milligrams the recipe must have.
        :param float max_sodium: The maximum amount of sodium in milligrams the recipe can have.
        :param float min_sugar: The minimum amount of sugar in grams the recipe must have.
        :param float max_sugar: The maximum amount of sugar in grams the recipe can have.
        :param float min_zinc: The minimum amount of zinc in milligrams the recipe must have.
        :param float max_zinc: The maximum amount of zinc in milligrams the recipe can have.
        :param int offset: The number of results to skip (between 0 and 900).
        :param int number: The maximum number of items to return (between 1 and 100). Defaults to 10.
        :param bool random: If true, every request will give you a random set of recipes within the requested limits.
        :param bool limit_license: Whether the recipes should have an open license that allows display with proper attribution.
        :return: list[InlineResponse2002]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['min_carbs', 'max_carbs', 'min_protein', 'max_protein', 'min_calories', 'max_calories', 'min_fat', 'max_fat', 'min_alcohol', 'max_alcohol', 'min_caffeine', 'max_caffeine', 'min_copper', 'max_copper', 'min_calcium', 'max_calcium', 'min_choline', 'max_choline', 'min_cholesterol', 'max_cholesterol', 'min_fluoride', 'max_fluoride', 'min_saturated_fat', 'max_saturated_fat', 'min_vitamin_a', 'max_vitamin_a', 'min_vitamin_c', 'max_vitamin_c', 'min_vitamin_d', 'max_vitamin_d', 'min_vitamin_e', 'max_vitamin_e', 'min_vitamin_k', 'max_vitamin_k', 'min_vitamin_b1', 'max_vitamin_b1', 'min_vitamin_b2', 'max_vitamin_b2', 'min_vitamin_b5', 'max_vitamin_b5', 'min_vitamin_b3', 'max_vitamin_b3', 'min_vitamin_b6', 'max_vitamin_b6', 'min_vitamin_b12', 'max_vitamin_b12', 'min_fiber', 'max_fiber', 'min_folate', 'max_folate', 'min_folic_acid', 'max_folic_acid', 'min_iodine', 'max_iodine', 'min_iron', 'max_iron', 'min_magnesium', 'max_magnesium', 'min_manganese', 'max_manganese', 'min_phosphorus', 'max_phosphorus', 'min_potassium', 'max_potassium', 'min_selenium', 'max_selenium', 'min_sodium', 'max_sodium', 'min_sugar', 'max_sugar', 'min_zinc', 'max_zinc', 'offset', 'number', 'random', 'limit_license']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_recipes_by_nutrients" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        if 'offset' in local_var_params and local_var_params['offset'] > 900:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `offset` when calling `search_recipes_by_nutrients`, must be a value less than or equal to `900`")  # noqa: E501
        if 'offset' in local_var_params and local_var_params['offset'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `offset` when calling `search_recipes_by_nutrients`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] > 100:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `search_recipes_by_nutrients`, must be a value less than or equal to `100`")  # noqa: E501
        if 'number' in local_var_params and local_var_params['number'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `number` when calling `search_recipes_by_nutrients`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'min_carbs' in local_var_params:
            query_params.append(('minCarbs', local_var_params['min_carbs']))  # noqa: E501
        if 'max_carbs' in local_var_params:
            query_params.append(('maxCarbs', local_var_params['max_carbs']))  # noqa: E501
        if 'min_protein' in local_var_params:
            query_params.append(('minProtein', local_var_params['min_protein']))  # noqa: E501
        if 'max_protein' in local_var_params:
            query_params.append(('maxProtein', local_var_params['max_protein']))  # noqa: E501
        if 'min_calories' in local_var_params:
            query_params.append(('minCalories', local_var_params['min_calories']))  # noqa: E501
        if 'max_calories' in local_var_params:
            query_params.append(('maxCalories', local_var_params['max_calories']))  # noqa: E501
        if 'min_fat' in local_var_params:
            query_params.append(('minFat', local_var_params['min_fat']))  # noqa: E501
        if 'max_fat' in local_var_params:
            query_params.append(('maxFat', local_var_params['max_fat']))  # noqa: E501
        if 'min_alcohol' in local_var_params:
            query_params.append(('minAlcohol', local_var_params['min_alcohol']))  # noqa: E501
        if 'max_alcohol' in local_var_params:
            query_params.append(('maxAlcohol', local_var_params['max_alcohol']))  # noqa: E501
        if 'min_caffeine' in local_var_params:
            query_params.append(('minCaffeine', local_var_params['min_caffeine']))  # noqa: E501
        if 'max_caffeine' in local_var_params:
            query_params.append(('maxCaffeine', local_var_params['max_caffeine']))  # noqa: E501
        if 'min_copper' in local_var_params:
            query_params.append(('minCopper', local_var_params['min_copper']))  # noqa: E501
        if 'max_copper' in local_var_params:
            query_params.append(('maxCopper', local_var_params['max_copper']))  # noqa: E501
        if 'min_calcium' in local_var_params:
            query_params.append(('minCalcium', local_var_params['min_calcium']))  # noqa: E501
        if 'max_calcium' in local_var_params:
            query_params.append(('maxCalcium', local_var_params['max_calcium']))  # noqa: E501
        if 'min_choline' in local_var_params:
            query_params.append(('minCholine', local_var_params['min_choline']))  # noqa: E501
        if 'max_choline' in local_var_params:
            query_params.append(('maxCholine', local_var_params['max_choline']))  # noqa: E501
        if 'min_cholesterol' in local_var_params:
            query_params.append(('minCholesterol', local_var_params['min_cholesterol']))  # noqa: E501
        if 'max_cholesterol' in local_var_params:
            query_params.append(('maxCholesterol', local_var_params['max_cholesterol']))  # noqa: E501
        if 'min_fluoride' in local_var_params:
            query_params.append(('minFluoride', local_var_params['min_fluoride']))  # noqa: E501
        if 'max_fluoride' in local_var_params:
            query_params.append(('maxFluoride', local_var_params['max_fluoride']))  # noqa: E501
        if 'min_saturated_fat' in local_var_params:
            query_params.append(('minSaturatedFat', local_var_params['min_saturated_fat']))  # noqa: E501
        if 'max_saturated_fat' in local_var_params:
            query_params.append(('maxSaturatedFat', local_var_params['max_saturated_fat']))  # noqa: E501
        if 'min_vitamin_a' in local_var_params:
            query_params.append(('minVitaminA', local_var_params['min_vitamin_a']))  # noqa: E501
        if 'max_vitamin_a' in local_var_params:
            query_params.append(('maxVitaminA', local_var_params['max_vitamin_a']))  # noqa: E501
        if 'min_vitamin_c' in local_var_params:
            query_params.append(('minVitaminC', local_var_params['min_vitamin_c']))  # noqa: E501
        if 'max_vitamin_c' in local_var_params:
            query_params.append(('maxVitaminC', local_var_params['max_vitamin_c']))  # noqa: E501
        if 'min_vitamin_d' in local_var_params:
            query_params.append(('minVitaminD', local_var_params['min_vitamin_d']))  # noqa: E501
        if 'max_vitamin_d' in local_var_params:
            query_params.append(('maxVitaminD', local_var_params['max_vitamin_d']))  # noqa: E501
        if 'min_vitamin_e' in local_var_params:
            query_params.append(('minVitaminE', local_var_params['min_vitamin_e']))  # noqa: E501
        if 'max_vitamin_e' in local_var_params:
            query_params.append(('maxVitaminE', local_var_params['max_vitamin_e']))  # noqa: E501
        if 'min_vitamin_k' in local_var_params:
            query_params.append(('minVitaminK', local_var_params['min_vitamin_k']))  # noqa: E501
        if 'max_vitamin_k' in local_var_params:
            query_params.append(('maxVitaminK', local_var_params['max_vitamin_k']))  # noqa: E501
        if 'min_vitamin_b1' in local_var_params:
            query_params.append(('minVitaminB1', local_var_params['min_vitamin_b1']))  # noqa: E501
        if 'max_vitamin_b1' in local_var_params:
            query_params.append(('maxVitaminB1', local_var_params['max_vitamin_b1']))  # noqa: E501
        if 'min_vitamin_b2' in local_var_params:
            query_params.append(('minVitaminB2', local_var_params['min_vitamin_b2']))  # noqa: E501
        if 'max_vitamin_b2' in local_var_params:
            query_params.append(('maxVitaminB2', local_var_params['max_vitamin_b2']))  # noqa: E501
        if 'min_vitamin_b5' in local_var_params:
            query_params.append(('minVitaminB5', local_var_params['min_vitamin_b5']))  # noqa: E501
        if 'max_vitamin_b5' in local_var_params:
            query_params.append(('maxVitaminB5', local_var_params['max_vitamin_b5']))  # noqa: E501
        if 'min_vitamin_b3' in local_var_params:
            query_params.append(('minVitaminB3', local_var_params['min_vitamin_b3']))  # noqa: E501
        if 'max_vitamin_b3' in local_var_params:
            query_params.append(('maxVitaminB3', local_var_params['max_vitamin_b3']))  # noqa: E501
        if 'min_vitamin_b6' in local_var_params:
            query_params.append(('minVitaminB6', local_var_params['min_vitamin_b6']))  # noqa: E501
        if 'max_vitamin_b6' in local_var_params:
            query_params.append(('maxVitaminB6', local_var_params['max_vitamin_b6']))  # noqa: E501
        if 'min_vitamin_b12' in local_var_params:
            query_params.append(('minVitaminB12', local_var_params['min_vitamin_b12']))  # noqa: E501
        if 'max_vitamin_b12' in local_var_params:
            query_params.append(('maxVitaminB12', local_var_params['max_vitamin_b12']))  # noqa: E501
        if 'min_fiber' in local_var_params:
            query_params.append(('minFiber', local_var_params['min_fiber']))  # noqa: E501
        if 'max_fiber' in local_var_params:
            query_params.append(('maxFiber', local_var_params['max_fiber']))  # noqa: E501
        if 'min_folate' in local_var_params:
            query_params.append(('minFolate', local_var_params['min_folate']))  # noqa: E501
        if 'max_folate' in local_var_params:
            query_params.append(('maxFolate', local_var_params['max_folate']))  # noqa: E501
        if 'min_folic_acid' in local_var_params:
            query_params.append(('minFolicAcid', local_var_params['min_folic_acid']))  # noqa: E501
        if 'max_folic_acid' in local_var_params:
            query_params.append(('maxFolicAcid', local_var_params['max_folic_acid']))  # noqa: E501
        if 'min_iodine' in local_var_params:
            query_params.append(('minIodine', local_var_params['min_iodine']))  # noqa: E501
        if 'max_iodine' in local_var_params:
            query_params.append(('maxIodine', local_var_params['max_iodine']))  # noqa: E501
        if 'min_iron' in local_var_params:
            query_params.append(('minIron', local_var_params['min_iron']))  # noqa: E501
        if 'max_iron' in local_var_params:
            query_params.append(('maxIron', local_var_params['max_iron']))  # noqa: E501
        if 'min_magnesium' in local_var_params:
            query_params.append(('minMagnesium', local_var_params['min_magnesium']))  # noqa: E501
        if 'max_magnesium' in local_var_params:
            query_params.append(('maxMagnesium', local_var_params['max_magnesium']))  # noqa: E501
        if 'min_manganese' in local_var_params:
            query_params.append(('minManganese', local_var_params['min_manganese']))  # noqa: E501
        if 'max_manganese' in local_var_params:
            query_params.append(('maxManganese', local_var_params['max_manganese']))  # noqa: E501
        if 'min_phosphorus' in local_var_params:
            query_params.append(('minPhosphorus', local_var_params['min_phosphorus']))  # noqa: E501
        if 'max_phosphorus' in local_var_params:
            query_params.append(('maxPhosphorus', local_var_params['max_phosphorus']))  # noqa: E501
        if 'min_potassium' in local_var_params:
            query_params.append(('minPotassium', local_var_params['min_potassium']))  # noqa: E501
        if 'max_potassium' in local_var_params:
            query_params.append(('maxPotassium', local_var_params['max_potassium']))  # noqa: E501
        if 'min_selenium' in local_var_params:
            query_params.append(('minSelenium', local_var_params['min_selenium']))  # noqa: E501
        if 'max_selenium' in local_var_params:
            query_params.append(('maxSelenium', local_var_params['max_selenium']))  # noqa: E501
        if 'min_sodium' in local_var_params:
            query_params.append(('minSodium', local_var_params['min_sodium']))  # noqa: E501
        if 'max_sodium' in local_var_params:
            query_params.append(('maxSodium', local_var_params['max_sodium']))  # noqa: E501
        if 'min_sugar' in local_var_params:
            query_params.append(('minSugar', local_var_params['min_sugar']))  # noqa: E501
        if 'max_sugar' in local_var_params:
            query_params.append(('maxSugar', local_var_params['max_sugar']))  # noqa: E501
        if 'min_zinc' in local_var_params:
            query_params.append(('minZinc', local_var_params['min_zinc']))  # noqa: E501
        if 'max_zinc' in local_var_params:
            query_params.append(('maxZinc', local_var_params['max_zinc']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'number' in local_var_params:
            query_params.append(('number', local_var_params['number']))  # noqa: E501
        if 'random' in local_var_params:
            query_params.append(('random', local_var_params['random']))  # noqa: E501
        if 'limit_license' in local_var_params:
            query_params.append(('limitLicense', local_var_params['limit_license']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/findByNutrients', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2002]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def summarize_recipe(self, id, **kwargs):  # noqa: E501
        """Summarize Recipe  # noqa: E501

        Automatically generate a short description that summarizes key information about the recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summarize_recipe(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.summarize_recipe_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.summarize_recipe_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def summarize_recipe_with_http_info(self, id, **kwargs):  # noqa: E501
        """Summarize Recipe  # noqa: E501

        Automatically generate a short description that summarizes key information about the recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.summarize_recipe_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method summarize_recipe" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `summarize_recipe`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_equipment(self, **kwargs):  # noqa: E501
        """Equipment Widget  # noqa: E501

        Visualize the equipment used to make a recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_equipment(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str accept: Accept header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_equipment_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.visualize_equipment_with_http_info(**kwargs)  # noqa: E501
            return data

    def visualize_equipment_with_http_info(self, **kwargs):  # noqa: E501
        """Equipment Widget  # noqa: E501

        Visualize the equipment used to make a recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_equipment_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str accept: Accept header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'accept']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_equipment" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501
        if 'accept' in local_var_params:
            header_params['Accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/visualizeEquipment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_price_breakdown(self, **kwargs):  # noqa: E501
        """Price Breakdown Widget  # noqa: E501

        Visualize the price breakdown of a recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_price_breakdown(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str accept: Accept header.
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_price_breakdown_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.visualize_price_breakdown_with_http_info(**kwargs)  # noqa: E501
            return data

    def visualize_price_breakdown_with_http_info(self, **kwargs):  # noqa: E501
        """Price Breakdown Widget  # noqa: E501

        Visualize the price breakdown of a recipe.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_price_breakdown_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str accept: Accept header.
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'accept', 'language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_price_breakdown" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'language' in local_var_params:
            query_params.append(('language', local_var_params['language']))  # noqa: E501

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501
        if 'accept' in local_var_params:
            header_params['Accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/visualizePriceEstimator', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_recipe_equipment_by_id(self, id, **kwargs):  # noqa: E501
        """Equipment by ID Widget  # noqa: E501

        Visualize a recipe's equipment list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_equipment_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_recipe_equipment_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.visualize_recipe_equipment_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def visualize_recipe_equipment_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Equipment by ID Widget  # noqa: E501

        Visualize a recipe's equipment list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_equipment_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'default_css']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_recipe_equipment_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `visualize_recipe_equipment_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'default_css' in local_var_params:
            query_params.append(('defaultCss', local_var_params['default_css']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/equipmentWidget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_recipe_ingredients_by_id(self, id, **kwargs):  # noqa: E501
        """Ingredients by ID Widget  # noqa: E501

        Visualize a recipe's ingredient list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_ingredients_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :param str measure: Whether the the measures should be 'us' or 'metric'.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_recipe_ingredients_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.visualize_recipe_ingredients_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def visualize_recipe_ingredients_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Ingredients by ID Widget  # noqa: E501

        Visualize a recipe's ingredient list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_ingredients_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :param str measure: Whether the the measures should be 'us' or 'metric'.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'default_css', 'measure']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_recipe_ingredients_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `visualize_recipe_ingredients_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'default_css' in local_var_params:
            query_params.append(('defaultCss', local_var_params['default_css']))  # noqa: E501
        if 'measure' in local_var_params:
            query_params.append(('measure', local_var_params['measure']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/ingredientWidget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_recipe_nutrition(self, **kwargs):  # noqa: E501
        """Recipe Nutrition Widget  # noqa: E501

        Visualize a recipe's nutritional information as HTML including CSS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_nutrition(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str accept: Accept header.
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_recipe_nutrition_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.visualize_recipe_nutrition_with_http_info(**kwargs)  # noqa: E501
            return data

    def visualize_recipe_nutrition_with_http_info(self, **kwargs):  # noqa: E501
        """Recipe Nutrition Widget  # noqa: E501

        Visualize a recipe's nutritional information as HTML including CSS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_nutrition_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content_type: The content type.
        :param str accept: Accept header.
        :param str language: The language of the input. Either 'en' or 'de'.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['content_type', 'accept', 'language']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_recipe_nutrition" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'language' in local_var_params:
            query_params.append(('language', local_var_params['language']))  # noqa: E501

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501
        if 'accept' in local_var_params:
            header_params['Accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/visualizeNutrition', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_recipe_nutrition_by_id(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition by ID Widget  # noqa: E501

        Visualize a recipe's nutritional information as HTML including CSS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_nutrition_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :param str accept: Accept header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_recipe_nutrition_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.visualize_recipe_nutrition_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def visualize_recipe_nutrition_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Recipe Nutrition by ID Widget  # noqa: E501

        Visualize a recipe's nutritional information as HTML including CSS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_nutrition_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :param str accept: Accept header.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'default_css', 'accept']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_recipe_nutrition_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `visualize_recipe_nutrition_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'default_css' in local_var_params:
            query_params.append(('defaultCss', local_var_params['default_css']))  # noqa: E501

        header_params = {}
        if 'accept' in local_var_params:
            header_params['Accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/nutritionWidget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_recipe_price_breakdown_by_id(self, id, **kwargs):  # noqa: E501
        """Price Breakdown by ID Widget  # noqa: E501

        Visualize a recipe's price breakdown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_price_breakdown_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_recipe_price_breakdown_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.visualize_recipe_price_breakdown_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def visualize_recipe_price_breakdown_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Price Breakdown by ID Widget  # noqa: E501

        Visualize a recipe's price breakdown.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_price_breakdown_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool default_css: Whether the default CSS should be added to the response.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'default_css']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_recipe_price_breakdown_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `visualize_recipe_price_breakdown_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'default_css' in local_var_params:
            query_params.append(('defaultCss', local_var_params['default_css']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/priceBreakdownWidget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_recipe_taste(self, **kwargs):  # noqa: E501
        """Recipe Taste Widget  # noqa: E501

        Visualize a recipe's taste information as HTML including CSS. You can play around with that endpoint!  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_taste(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str language: The language of the input. Either 'en' or 'de'.
        :param str content_type: The content type.
        :param str accept: Accept header.
        :param bool normalize: Whether to normalize to the strongest taste.
        :param str rgb: Red, green, blue values for the chart color.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_recipe_taste_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.visualize_recipe_taste_with_http_info(**kwargs)  # noqa: E501
            return data

    def visualize_recipe_taste_with_http_info(self, **kwargs):  # noqa: E501
        """Recipe Taste Widget  # noqa: E501

        Visualize a recipe's taste information as HTML including CSS. You can play around with that endpoint!  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_taste_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str language: The language of the input. Either 'en' or 'de'.
        :param str content_type: The content type.
        :param str accept: Accept header.
        :param bool normalize: Whether to normalize to the strongest taste.
        :param str rgb: Red, green, blue values for the chart color.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['language', 'content_type', 'accept', 'normalize', 'rgb']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_recipe_taste" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'language' in local_var_params:
            query_params.append(('language', local_var_params['language']))  # noqa: E501
        if 'normalize' in local_var_params:
            query_params.append(('normalize', local_var_params['normalize']))  # noqa: E501
        if 'rgb' in local_var_params:
            query_params.append(('rgb', local_var_params['rgb']))  # noqa: E501

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['Content-Type'] = local_var_params['content_type']  # noqa: E501
        if 'accept' in local_var_params:
            header_params['Accept'] = local_var_params['accept']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/visualizeTaste', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def visualize_recipe_taste_by_id(self, id, **kwargs):  # noqa: E501
        """Recipe Taste by ID Widget  # noqa: E501

        Get a recipe's taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_taste_by_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool normalize: Whether to normalize to the strongest taste.
        :param str rgb: Red, green, blue values for the chart color.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.visualize_recipe_taste_by_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.visualize_recipe_taste_by_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def visualize_recipe_taste_by_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Recipe Taste by ID Widget  # noqa: E501

        Get a recipe's taste. The tastes supported are sweet, salty, sour, bitter, savory, and fatty.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.visualize_recipe_taste_by_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The item's id. (required)
        :param bool normalize: Whether to normalize to the strongest taste.
        :param str rgb: Red, green, blue values for the chart color.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'normalize', 'rgb']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method visualize_recipe_taste_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ApiValueError("Missing the required parameter `id` when calling `visualize_recipe_taste_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'normalize' in local_var_params:
            query_params.append(('normalize', local_var_params['normalize']))  # noqa: E501
        if 'rgb' in local_var_params:
            query_params.append(('rgb', local_var_params['rgb']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['apiKeyScheme']  # noqa: E501

        return self.api_client.call_api(
            '/recipes/{id}/tasteWidget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
